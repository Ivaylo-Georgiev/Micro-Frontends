<!DOCTYPE html>
<html lang="bg" dir="ltr">

<head>
    <meta charset="utf-8">
    <title>Micro Frontends - extending the microservice idea to frontend development</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Oswald&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz&display=swap" rel="stylesheet">
</head>

<body>

    <header>
        <h1>Micro Frontends - extending the microservice idea to frontend development</h1>
    </header>

    <main>
        <section class="contents">
            <h2>Съдържание:</h2>
            <ol>
                <li><a href="#">Какво е micro frontend?</a></li>
                <li><a href="#">Основни идеи на micro frontend</a></li>
                <li><a href="#">Монолитният подход не работи за големи приложения</a></li>
                <li><a href="#">Имплементиране на micro frontends</a>
                    <ol type="a">
                        <li><a href="#">Споделен код</a></li>
                        <li><a href="#">Съставен frontend</a></li>
                        <li><a href="#">Преизползваеми уеб компоненти</a>
                            <ol type="i">
                                <li><a href="#">Дефиниране на нов елемент</a></li>
                                <li><a href="#">Наследяване на елемент</a></li>
                                <li><a href="#">Поддръжка от браузъри</a></li>
                            </ol>
                        </li>
                    </ol>
                </li>
                <li><a href="#">Пример</a>
                    <ol type="a">
                        <li><a href="#">Създаване на отделни компоненти</a></li>
                        <li><a href="#">Свързване на отделните компоненти</a></li>
                    </ol>
                </li>
                <li><a href="#">Аргументи срещу micro frontend архитектурата</a></li>
                <li><a href="#">Заключение</a></li>
                <li><a href="#">Източници</a></li>
            </ol>
        </section>

        <article>
          <h2>Какво е micro frontend?</h2>
          <p>Терминът micro frontend за първи път се появява в ThoughtWorks Technology Radar в края на 2016 година. Той разширява концепцията за micro services във frontend света. Текущите тенденции са за изграждане на богати на функционалности браузър приложения на основата на micro services архитектурата. С течение на времето, frontend слоят, често разработван от отделен екип, расте и става сложен за поддръжка. Това се нарича frontend монолит.</p>
          <p>Идеята на micro frontend е да се мисли за уеб приложенията като композиция от функционалности, поддържани от независими екипи. Всеки екип се занимава с отделна бизнес зона, от която се интересува и върху която се специализира. Екипите са с пресичащи се функционални дялове и разработват приложенията си от край до край - от база данни до потребителски интерфейс.</p>

          <h2>Основни идеи на micro frontend</h2>
          <ul>
            <li>Бъдете технологично агностически</li>
            <p>Всеки екип трябва да има възможност да избере и подмени технологичния стек, който използва без да се координира с другите екипи.</p>
            <li>Изолирайте екипния код</li>
            <p>Не споделяйте среда за изпълнение, дори ако използвате една и съща технология. Не разчитайте на споделено състояние или глобални променливи.</p>
            <li>Установете конвенции за наименование</li>
            <p>Съгласете се за общи конвенции за наименование там, където изолацията не е възможна. Използвайте пространства от имена, за да предотвратите колизии.</p>
            <li>Предпочитайте функционалности на браузъра пред персонализирани приложно-програмни интерфейси</li>
            <p>Ако наистина трябва да създадете приложно-програмен интерфейс между отделни екипи, се старайте той да е възможно най-опростен.</p>
            <li>Създавайте гъвкави приложения</li>
            <p>Вашите функционалности трябва да са използваеми от гледна точка на потребителя, дори след появата на грешки.</p>
          </ul>

          <h2>Монолитният подход не работи за големи приложения</h2>
          <p>Монолитният подход при големи frontend приложения е тромав. Необходимо е да се намери начин тези приложения да бъдат разделени на по-малки модули, които да се държат независимо.</p>
          <p>Например:</p>
          <ul>
            <li><code class="inline-code">myapp.com/</code> - основната страница, създадена със статичен HTML.</li>
            <li><code class="inline-code">myapp.com/settings</code> - стар модул с настройки, създаден с AngularJS 1.x.</li>
            <li><code class="inline-code">myapp.com/dashboard</code> - модул с табло за наблюдение, създаден с React.</li>
          </ul>
          <p>При този сценарий следното би било нужно:</p>
          <ol>
            <li>Споделена кодова база на чист JavaScript например за пренасочване и потребителски сесии. Също и споделен CSS. И двете трябва да са възможно най- олекотени.</li>
            <li>Колекция от отделни модули - мини приложения, създадени с разнообразни технологии и запазени в различни хранилища.</li>
            <li>Система за внедряване, която събира всички модули заедно от отделните хранилища.</li>
          </ol>
          <p>Решението е micro frontend. Компании като Spotify, Klarna, Zalando, Upwork и Allegro използват тази архитектура за уеб сайтовете си.</p>

          <h2>Имплементиране на micro frontends</h2>
          <p>Представете си, че работите за компания, която преминава от монолитна архитектура към microservices. Наскоро сте открили няколко независими функционалности и досегашният монолит се е стеснил до отделни backend microservices и отделна услуга, предоставяща потребителския интерфейс. Frontend модулът, обаче все още е монолитът, който се разгръща над останалите услуги. Това означава, че за него все още съществуват същите проблеми, както преди рефакторирането към microservices модела. Фигура 1 обобщава текущата ситуация:</p>
          <img src="../images/Figure 1.png" alt="Фигура 1 Microservices архитектура с монолитен frontend">
          <figcaption>Фигура 1 Microservices архитектура с монолитен frontend</figcaption>
          <p>Когато се имплементира microservices архитектура, целта е услугите да са малки. Същото трябва да важи и за frontend стека. Въпреки че едно приложение не може да бъде напълно разделено на няколко по-малки, няколко екипа могат да работят по отделни части frontend, сякаш те са напълно различни приложения. По този начин се постига вертикална декомпозиция на едно цялостно консистентно приложение (Фигура 2).</p>
          <img src="../images/Figure 2.png" alt="Фигура 2 Вертикална декомпозиция">
          <figcaption>Фигура 2 Вертикална декомпозиция</figcaption>
          <p>Вертикалната декомпозиция е осъществима по един от следните начини:</p>
          <h3>Споделен код</h3>
          <p>Кодът може да бъде споделен, за да се подсигури консистентност на потребителския интерфейс. За съжаление, по този начин се рискува да се обвържат отделните услуги чрез споделения код. Това дори би довело до невъзможност за внедряване и публикуване на модулите поотделно.</p>
          <p>Ето защо, когато се използва споделен код е необходимо да се помисли за предоставените приложно-програмни интерфейси. Наименуването на библиотека “common”, например не е добра идея. Това означава, че целта на библиотеката не е да предостави определена функционалност, а по-скоро всякакъв код, който може да се ползва от отделните услуги. Това резултира в приложно-програмен интерфейс без определена цел, а това от своя страна, води до чести поводи за промяна.</p>
          <p>Въпреки че споделеният код си има недостатъци, в общия случай, всяка microservices архитектура го използва посредством библиотеки с отворен код. Понеже такъв код винаги се използва в много проекти, специално внимание се отделя на съвместимостта с различните версии.</p>
          <h3>Съставен frontend</h3>
          <p>Възможно е frontend частта на едно приложение да бъде съставено от различни компоненти. Всеки от тях се поддържа от отделни екипи и се внедрява независимо от останалите. Фигура 3 показва един примерен съставен frontend:</p>
          <img src="../images/Figure 3.png" alt="Фигура 3 Съставен frontend">
          <figcaption>Фигура 3 Съставен frontend</figcaption>
          <p>Отделните компоненти могат да се интегрират по време на разработка, внедряване или изпълнение. Всеки метод си има и предимства, и недостатъци. Комбинирането на множество компоненти чрез споделени библиотеки в един frontend, е пример за интегриране по време на разработката. Този подход, обаче, не предоставя достатъчно гъвкавост при внедряването на отделните модули. Повече гъвкавост може да се намери при внедряването по време на изпълнение. Пример за това е използването на AJAX за зареждане на HTML. При този сценарий, приложението единствено трябва да знае от къде да получи компонентите си. Проблемът тук е, че изпълнението на заявките отнема време.</p>
          <p>Интеграцията може да бъде осъществена също така  с помощта на iFrames, web components, server-side integration, client-side JavaScript, routing, shadow DOM и други, като всеки от методите си има предимства и недостатъци.</p>
          <h3>Преизползваеми уеб компоненти</h3>
          <p>С персонализирани елементи, уеб разработчиците могат да създават нови HTML тагове или да променят текущи такива. Този приложно-програмен интерфейс е в основата на <a href="https://www.webcomponents.org/" target="_blank">уеб компонентите</a>. Той определя стандартизиран начин за създаване на преизползваеми компоненти, използвайки нищо повече от чист JavaScript/HTML/CSS. Резултатът е по-малко код, който е модулен и може да се използва повече от веднъж в приложенията ни.</p>
          <h4>Дефиниране на нов елемент</h4>
          <p>За да дефинираме нов HTML елемент, ни е необходим JavaScript. Глобалната променлива <code class="inline-code">customElements</code> се използва за дефиниране на персонализиран елемент и за обучаване на браузъра за нов таг. Извиквайки <code class="inline-code">customElements.define()</code> с името на тага, който искаме да създадем и JavaScript клас, наследяващ <code class="inline-code">HTMLElement</code>, е всичко, от което се нуждаем.</p>
          <p>Пример: дефиниране на таг <code class="inline-code">&lt;app-drawer&gt;</code>:</p>
          <code class="code-block">class AppDrawer extends HTMLElement {...}
window.customElements.define('app-drawer', AppDrawer);</code>
          <h4>Наследяване на елемент</h4>
          <p>Освен за създаване на нови елементи, приложно-програмният интерфейс за персонализирани елементи предоставя възможност за разширяване на други елементи, включително и на тези, които са вградени в браузъра.</p>
          <p>Пример: дефиниране на <code class="inline-code">&lt;fancy-app-drawer&gt;</code>, който наследява <code class="inline-code">&lt;app-drawer&gt;</code>:</p>
          <code class="code-block">class FancyDrawer extends AppDrawer {
  constructor() {
    super();
  }
}

customElements.define('fancy-app-drawer', FancyDrawer);</code>
          <h4>Поддръжка от браузъри</h4>
          <p>Chrome 54, Safari 10.1 и Firefox 63 поддържат персонифицирани елементи. Докато поддръжката стане широкодостъпна, съществува <a href="https://github.com/webcomponents/custom-elements/" target="_blank">polyfill</a>, който може да бъде използван.</p>


        </article>
    </main>

</body>

</html>
